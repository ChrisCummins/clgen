#!/usr/bin/env python
"""Configure and build the phd toolchain.

Creates a config.pbtxt proto.
"""
from __future__ import print_function

import argparse
import hashlib
import logging
import os
import re
import subprocess
import sys


# The path to the root of the PhD repository, i.e. the directory which this file
# is in.
PHD_ROOT = os.path.dirname(os.path.realpath(__file__))
# The path to the config proto file which this script generates.
CONFIG_PROTO_PATH = os.path.join(PHD_ROOT, 'config.pbtxt')


def GetConfigId(args):
  """Get the ID of the configuration.

  The configuration ID is a sha256 which uniquely identifies both the set of
  configuration options requested by the user, and the contents of this file.
  If either this file or the options change, the return value of this function
  will change.

  Arguments:
    args: The arguments namespace which is returned by
      ArgumentParser.parse_args().

  Returns:
    A 64 character hexadecimal string.
  """
  sha256 = hashlib.sha256()
  with open(__file__, 'rb') as f:
    sha256.update(f.read())
    for arg in sorted(args.__dict__.keys()):
      # The --id argument does not modify the ID.
      if arg != 'print_id':
        sha256.update('{}'.format(args.__dict__[arg]).encode('utf-8'))
  return sha256.hexdigest()


def GetCachedConfigId():
  """Get the ID of the last run configuration, if any.

  Returns:
    A 64 character hexadecimal string, or None if ./configure has not been run
    before.
  """
  if not os.path.isfile(CONFIG_PROTO_PATH):
    return None

  with open(CONFIG_PROTO_PATH) as f:
    # Very crude text_format proto parsing!
    for line in f.readlines():
      if 'configure_id:' in line:
        try:
          return re.search(r'configure_id:\s*"([0-9a-f]{64})"', line).group(1)
        except AttributeError:
          pass
  logging.warning(
      "Could not find field 'configure_id' in proto: '%s'", CONFIG_PROTO_PATH)
  return None


def GetCudaHome():
  """Get the CUDA home directory."""
  return os.environ.get('CUDA_HOME', '/usr/local/cuda')


def GuessIfCudaIsAvailable():
  """Guess if CUDA is available on the host."""
  nvcc_path = os.path.join(GetCudaHome(), 'bin/nvcc')
  is_available = os.path.isfile(nvcc_path)
  if is_available:
    logging.info("CUDA found at: '%s'.", nvcc_path)
  else:
    logging.info("CUDA not found at: '%s'.", nvcc_path)
  return is_available


def IsGitRepo():
  """Determine if it is a git repo."""
  return os.path.isdir(os.path.join(os.path.dirname(__file__), '.git'))


def GetGitRemote():
  """Get the git remote for this repo."""
  remotes = subprocess.check_output(
      ['git', '-C', os.path.dirname(__file__), 'remote', '-v']).decode('utf-8')
  return remotes.split('\n')[0].split()[1]


def RewriteGitSubmodulesToHttps():
  """Rewrite git@ prefixed submodules to https://."""
  with open(os.path.join(os.path.dirname(__file__), '.gitmodules')) as f:
    modules = f.read()
  new_modules = re.sub(r'(url\s*=\s*)git@', r'\1https=', modules)
  assert 'git@' not in new_modules
  with open(os.path.join(os.path.dirname(__file__), '.gitmodules'), 'w') as f:
    f.write(new_modules)


def RunAsHomebrewUser(cmd, subprocess_fn=subprocess.check_call):
  if os.path.isdir('/home/linuxbrew'):
    return subprocess_fn(
        ['sudo', '-H', '-u', 'linuxbrew', 'bash', '-c', ' '.join(cmd)])
  else:
    return subprocess_fn(cmd)


def main(argv):
  logging.basicConfig(level=logging.DEBUG, format='%(message)s')

  parser = argparse.ArgumentParser()
  parser.add_argument('--with_cuda', dest='cuda', action='store_true',
                      help=('Enable CUDA support. This requires that '
                            'CUDA is installed on the host machine.'))
  parser.add_argument('--nowith_cuda', dest='cuda', action='store_false',
                      help='Disable CUDA support.')
  parser.set_defaults(cuda=True)
  parser.add_argument(
      '--cache_result', dest='cache_result', action='store_true',
      help='Cache the results of configure.')
  parser.add_argument(
      '--nocache_result', dest='cache_result', action='store_false',
      help='Disable caching of configure results.')
  parser.set_defaults(cache_result=True)
  parser.add_argument('--id', dest='print_id', action='store_true',
                      help='Print the configure ID and exit.')
  args = parser.parse_args(argv)

  phd_root = os.path.dirname(os.path.realpath(__file__))
  os.chdir(phd_root)

  # Calculate config ID and compare against cached ID (if it exists).
  config_id = GetConfigId(args)
  if args.print_id:
    print(config_id)
    return
  cached_config_id = GetCachedConfigId()
  if args.cache_result and config_id == cached_config_id:
    return

  logging.info('Config ID: %s', config_id)

  # Uname in lowercase.
  uname_path = '/usr/bin/uname'
  if os.path.isfile('/bin/uname'):
    uname_path = '/bin/uname'
  uname = subprocess.check_output(
      [uname_path], universal_newlines=True).rstrip().lower()

  if IsGitRepo():
    git_remote = GetGitRemote()
    logging.info('Git remote: %s', git_remote)
    # Rewrite git@ to https:// if required.
    if git_remote.startswith('https://'):
      logging.info('Rewriting .gitmodules to use https://')
      RewriteGitSubmodulesToHttps()
    # Update submodules.
    logging.info('Updating git submodules.')
    subprocess.check_call(
        ['git', '-C', phd_root, 'submodule', 'update', '--init', '--recursive'],
        stdout=subprocess.DEVNULL)
  else:
    logging.info('Not a git repo.')

  with_cuda = False
  if args.cuda and GuessIfCudaIsAvailable():
    with_cuda = True

  dotfiles_run_path = os.path.join(phd_root, 'system', 'dotfiles', 'run')
  assert os.path.isfile(dotfiles_run_path)
  proc = subprocess.Popen([dotfiles_run_path, 'PhdBuildDeps'])
  proc.communicate()

  if uname == 'darwin':
    python_path = '/usr/local/opt/python/bin/python3'
  else:
    python_path = '/home/linuxbrew/.linuxbrew/bin/python3'
  assert os.path.isfile(python_path)

  base_requirements_txt_path = os.path.join(
      phd_root, 'tools', 'requirements.txt')
  assert os.path.isfile(base_requirements_txt_path)
  with open(base_requirements_txt_path) as f:
    base_requirements = f.read()

  if with_cuda:
    requirements_txt = base_requirements.replace(
        'tensorflow=', 'tensorflow-gpu=')
  else:
    requirements_txt = base_requirements

  requirements_txt_path = os.path.join(phd_root, 'requirements.txt')
  with open(requirements_txt_path, 'w') as f:
    f.write(requirements_txt)

  pip_packages = RunAsHomebrewUser(
      [python_path, '-m', 'pip', 'freeze'], subprocess.check_output).decode(
      'utf-8')
  if with_cuda and 'tensorflow==' in pip_packages:
    logging.info('Detected CUDA, so uninstalling CPU TensorFlow')
    RunAsHomebrewUser(
        [python_path, '-m', 'pip', 'uninstall', '-y', '-q', 'tensorflow'])
  elif not with_cuda and 'tensorflow-gpu==' in pip_packages:
    logging.info('CUDA not detected, so uninstalling GPU TensorFlow')
    RunAsHomebrewUser(
        [python_path, '-m', 'pip', 'uninstall', '-y', '-q', 'tensorflow-gpu'])

  logging.info('Installing Python packages')
  RunAsHomebrewUser(
      [python_path, '-m', 'pip', 'install', '--no-warn-script-location', '-q',
       '-r', requirements_txt_path])

  if uname == 'darwin':
    assert os.path.isfile('/usr/local/bin/brew')
    brew_prefix = '/usr/local'
  else:
    assert os.path.isfile('/home/linuxbrew/.linuxbrew/bin/brew')
    brew_prefix = '/home/linuxbrew/.linuxbrew'

  npm_path = os.path.join(brew_prefix, 'bin', 'npm')
  assert os.path.isfile(npm_path)
  if not os.path.isdir(os.path.join(phd_root, 'node_modules', 'husky')):
    proc = subprocess.Popen(
        [npm_path, 'install', '--cwd', phd_root, 'husky', '--save-dev'])
    proc.communicate()

  llvm_prefix = os.path.join(brew_prefix, 'opt', 'llvm')
  # Sanity check to ensure that LLVM was installed correctly.
  assert os.path.isfile(os.path.join(llvm_prefix, 'bin', 'clang'))
  assert os.path.isfile(os.path.join(llvm_prefix, 'bin', 'clang-format'))
  assert os.path.isfile(os.path.join(llvm_prefix, 'bin', 'clang++'))
  assert os.path.isfile(os.path.join(llvm_prefix, 'bin', 'opt'))

  libclang_so_path = os.path.join(llvm_prefix, 'lib', 'libclang.so')
  if not os.path.isfile(libclang_so_path):
    libclang_so_path = ''

  with open(os.path.join(phd_root, 'config.pbtxt'), 'w') as f:
    f.write("""\
# Global configuration options. Generated by ./configure. DO NOT EDIT!
# File: //config/proto/config.proto
# Proto: phd.GlobalConfig
uname: "{uname}"
configure_id: "{config_id}"
with_cuda: {with_cuda}
paths {{
  repo_root: "{phd_root}"
  cc: "{llvm_prefix}/bin/clang"
  cxx: "{llvm_prefix}/bin/clang++"
  opt: "{llvm_prefix}/bin/opt"
  libclang_so: "{libclang_so}"
  clang_format: "{llvm_prefix}/bin/clang-format"
  python: "{python_path}"
  llvm_prefix: "{llvm_prefix}"
}}
""".format(uname=uname, config_id=config_id, phd_root=phd_root,
           with_cuda='true' if with_cuda else 'false', llvm_prefix=llvm_prefix,
           libclang_so=libclang_so_path, python_path=python_path))

  # On Linux systems we use the homebrew-installed clang. On macOS we use the
  # system clang.
  if uname == 'darwin':
    cc = 'clang'
    cxx = 'clang++'
  else:
    cc = os.path.join(llvm_prefix, 'bin', 'clang')
    cxx = os.path.join(llvm_prefix, 'bin', 'clang++')

  with open(os.path.join(phd_root, '.env'), 'w') as f:
    f.write("""\
#!/bin/bash
# Shell environment for the project. Generated by ./configure. DO NOT EDIT!

# Export a dummy virtualenv.
# TODO(cec): Add a better way of signalling that we're in the phd env from
# the command line.
export VIRTUAL_ENV=phd

export PHD="{phd_root}"
export CC="{cc}"
export CXX="{cxx}"
export PYTHON="{python_path}"

export PYTHONPATH={phd_root}:{phd_root}/lib:{phd_root}/bazel-genfiles

clgen() {{
  bazel build //deeplearning/clgen
  {phd_root}/bazel-phd/bazel-out/*-py3-opt/bin/deeplearning/clgen/clgen $@
}}
""".format(phd_root=phd_root, cc=cc, cxx=cxx, python_path=python_path))


if __name__ == '__main__':
  main(sys.argv[1:])
