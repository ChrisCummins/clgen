#!/usr/bin/env python
"""Configure and build the phd toolchain.

Creates a config.pbtxt proto.
"""
from __future__ import print_function

import argparse
import hashlib
import logging
import os
import re
import subprocess

import sys


def GetConfigId(args):
  sha256 = hashlib.sha256()
  with open(__file__, 'rb') as f:
    sha256.update(f.read())
    for arg in sorted(args.__dict__.keys()):
      sha256.update('{}'.format(args.__dict__[arg]).encode('utf-8'))
  return sha256.hexdigest()


def GetCachedConfigId():
  config_proto_path = os.path.join(
      os.path.dirname(os.path.realpath(__file__)), 'config.pbtxt')
  if not os.path.isfile(config_proto_path):
    print('no file', config_proto_path, __file__)
    return None

  with open(config_proto_path) as f:
    for line in f.readlines():
      if 'configure_id:' in line:
        try:
          return re.search(r'configure_id:\s*"([0-9a-f]{64})"', line).group(1)
        except AttributeError:
          pass
  return None


def GetCudaHome():
  """Get the CUDA home directory."""
  return os.environ.get('CUDA_HOME', '/usr/local/cuda')


def GuessIfCudaIsAvailable():
  """Guess if CUDA is available on the host."""
  nvcc_path = os.path.join(GetCudaHome(), 'bin/nvcc')
  is_available = os.path.isfile(nvcc_path)
  if is_available:
    logging.info("CUDA found at: '%s'.", nvcc_path)
  else:
    logging.info("CUDA not found.")
  return is_available


def IsGitRepo():
  """Determine if it is a git repo."""
  return os.path.isdir(os.path.join(os.path.dirname(__file__), '.git'))


def GetGitRemote():
  """Get the git remote for this repo."""
  remotes = subprocess.check_output(
      ['git', '-C', os.path.dirname(__file__), 'remote', '-v']).decode('utf-8')
  return remotes.split('\n')[0].split()[1]


def RewriteGitSubmodulesToHttps():
  """Rewrite git@ prefixed submodules to https://."""
  with open(os.path.join(os.path.dirname(__file__), '.gitmodules')) as f:
    modules = f.read()
  new_modules = re.sub(r'(url\s*=\s*)git@', r'\1https=', modules)
  assert 'git@' not in new_modules
  with open(os.path.join(os.path.dirname(__file__), '.gitmodules'), 'w') as f:
    f.write(new_modules)


def main(argv):
  logging.basicConfig(level=logging.DEBUG, format='%(message)s')

  parser = argparse.ArgumentParser()
  parser.add_argument('--with_cuda', dest='cuda', action='store_true',
                      help=('Enable CUDA support. This requires that '
                            'CUDA is installed on the host machine.'))
  parser.add_argument('--nowith_cuda', dest='cuda', action='store_false',
                      help=('Disable CUDA support.'))
  parser.set_defaults(cuda=True)
  parser.add_argument(
      '--cache_result', dest='cache_result', action='store_true',
      help='Cache the results of configure.')
  parser.add_argument(
      '--nocache_result', dest='cache_result', action='store_false',
      help='Disable caching of configure results.')
  parser.set_defaults(cache_result=True)
  args = parser.parse_args(argv)

  # Calculate config ID and compare against cached ID (if it exists).
  config_id = GetConfigId(args)
  cached_config_id = GetCachedConfigId()
  if args.cache_result and config_id == cached_config_id:
    return

  uname = subprocess.check_output(
      ['/usr/bin/uname'], universal_newlines=True).rstrip()

  if IsGitRepo():
    git_remote = GetGitRemote()
    logging.info('Git remote: %s', git_remote)
    # Rewrite git@ to https:// if required.
    if git_remote.startswith('https://'):
      logging.info('Rewriting .gitmodules to use https://')
      RewriteGitSubmodulesToHttps()
    # Update submodules.
    logging.info('Updating git submodules.')
    subprocess.check_call(['git', '-C', os.path.dirname(__file__),
                           'submodule', 'update', '--init', '--recursive'],
                          stdout=subprocess.DEVNULL)
  else:
    logging.info('Not a git repo.')

  with_cuda = False
  if args.cuda and GuessIfCudaIsAvailable():
    with_cuda = True

  dotfiles_run_path = os.path.join(
      os.path.dirname(os.path.realpath(__file__)), 'system', 'dotfiles', 'run')
  assert os.path.isfile(dotfiles_run_path)
  proc = subprocess.Popen([dotfiles_run_path, 'PhdBuildDeps'])
  proc.communicate()

  if uname == "Darwin":
    python_path = '/usr/local/opt/python/bin/python3'
  else:
    python_path = '/home/linuxbrew/.linuxbrew/bin/python3'
  assert os.path.isfile(python_path)

  base_requirements_txt_path = os.path.join(
      os.path.dirname(os.path.realpath(__file__)), 'tools', 'requirements.txt')
  assert os.path.isfile(base_requirements_txt_path)
  with open(base_requirements_txt_path) as f:
    base_requirements = f.read()

  if with_cuda:
    requirements_txt = base_requirements.replace(
        'tensorflow=', 'tensorflow-gpu=')
  else:
    requirements_txt = base_requirements

  requirements_txt_path = os.path.join(
      os.path.dirname(os.path.realpath(__file__)), 'requirements.txt')
  with open(requirements_txt_path, 'w') as f:
    f.write(requirements_txt)

  # TODO(cec): Uninstall the *other* tensorflow package. E.g. if installing
  # tensorflow-gpu, uninstall tensorflow.

  proc = subprocess.Popen(
      [python_path, '-m', 'pip', 'install', '-r', requirements_txt_path])
  proc.communicate()


if __name__ == '__main__':
  main(sys.argv[1:])
